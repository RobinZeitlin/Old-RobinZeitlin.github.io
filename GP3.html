<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" href="vec/icon.svg" type="image/svg+xml">
  
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="stylesfocused.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <title>Robin Zeitlin</title>
    <style>
        /* Scrollbar styling for WebKit browsers */
        ::-webkit-scrollbar {
          width: 12px; /* Width of the scrollbar */
        }

        .seymour-one-font {
          font-family: 'Seymour One', sans-serif;
        }

      </style>

<link rel="stylesheet" href="prism.css" data-noprefix>
<script src="prism.js" defer></script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
</head>
<div>
    <body>

      <div class="corner-container">
        <a class="hover-text" style="color: #6093ff" ; href="https://www.linkedin.com/in/robin-zeitlin-778a9127a/">Robin Zeitlin | LinkedIn</a>
        <p></p>
        <a class="hover-text" style="color: #6093ff" ;href="https://github.com/RobinZeitlin?tab=repositories">Robin Zeitlin | Github</a>
        <p></p>
        <a class="hover-text" style="color: #6093ff" ;href="mailto:robin.zeitlin@hotmail.com">robin.zeitlin@hotmail.com</a>
      </div>

        <div class="background-container">
            <img src="images/beige.jpg">
            <img class="moving-image-background" src="images/GP3/placeholderGP3.png">

            <div class="vertical-text">
              Made by Robin.
            </div>

            <div class="title-text"> 
              <h1 class="seymour-one-font"> </h1>
            </div>

                <div class="smallContainer" opacity>
                    <div class="video" opacity>
                      <iframe width="100%" height="70%" src="https://www.youtube.com/embed/n1oLyScA9nQ?si=us9MbsJCLkawGUr6" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
                      <div class="text-under-video">

                      <div style="display: flex;">
                        <h1 style="font-size: 8vh; margin: 5%;">FruityWars.</h1>
                        <div style="margin-left: 10px;">
                          <p>This project was made togheter in a group of 10 people as our GP3 project at FutureGames the project was made in 7 weeks and was made in Unreal Engine and we used the source controll Perforce.</p>
                          <p>After completing this project the game was published on Steam 2024-06-15.</p>
                          <p><a class="hover-text" style="color: #b3c8f5" href="https://store.steampowered.com/app/2875910/Honker/">-> FruityWars steam page <-</a></p>
                          </div>
                      </div>
                      
                      <div class="box-container">
                        
                        <div class="box">
                          <h2 class="oswald-font"; style="color: #E1E1E1" >Goals</h2>
                          <h2 class="click-this">Click Here</h2>
                          <div class="hidden-text">
                            <p>1. Efficiently work in a larger group project.</p>
                            <p>2. Use C++ in Unreal Engine</p>
                          </div>
                        </div>

                          <div class="my-line"></div>

                          <div style="display: flex; align-items: center;">
                            <img style="height: 30%; width: 30%; margin: 5%;" src="images/GP3/FinishedThrow.gif">
                            <div style="margin-left: 10px; display: flex; flex-direction: column; justify-content: center;">
                              <h2 style="color: #fabf66;">Parabolic-Function based throwing -> Tldr</h2>
                              <p>Using a parbolic function calculate the path that the projectile should take when travelling towards the target point.</p>
                              <div class="math-snippet" style="font-size: larger;">
                                <pre><code id="codeBlock">
y = a(x - h)^2 + k
                                </code></pre>
                              </div>
                            </div>
                        </div>
                          

                          <div class="box">
                            <h3 class="oswald-font">Throwing Projectile | Code</h3>
                            <h3 class="click-this">Click Here</h3>
                            <div class="hidden-text">
                              <div class="code-snippet">
                                <pre><code id="codeBlock">
<h2 style="color: gray;">//Functions to handle aiming.</h2>
void UPlayerThrowComponent::Aim()
{
    ChangeCameraState(true);
    bIsAiming = true;
}

void UPlayerThrowComponent::StopAim()
{
    if (bReleaseToShoot)
        SpawnAndFollowProjectile(TrajectoryPoints);

    ChangeCameraState(false);
    ClearTrajectoryMeshes();
    bIsAiming = false;
}

<h2 style="color: gray;">//Main throw function.</h2>
void UPlayerThrowComponent::Throw()
{   
    UUUnitHandler* UnitHandlerRef = Cast<UUUnitHandler>(GetOwner()->GetComponentByClass(UUUnitHandler::StaticClass()));

    if(UnitHandlerRef == nullptr)
	{
		GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, TEXT("UnitHandler is null"));
		return;
	}

    if (UnitHandlerRef->CurrentUnits <= 0)
    {
		GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, TEXT("No units to throw"));
		return;
	}

    if (!bReleaseToShoot && bIsAiming && bRayHit) 
    {
        SpawnAndFollowProjectile(TrajectoryPoints);
        UnitHandlerRef->CurrentUnits--;
    }
}

<h2 style="color: gray;">//Calls Debugs and Raycast.</h2> 
void UPlayerThrowComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
    Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
    if (GEngine)
    {
        FColor DebugColor = bIsAiming ? FColor::Green : FColor::Red;
        DrawDebugString(GetWorld(), FVector(0, 0, 100), bIsAiming ? "Aiming" : "Not Aiming", GetOwner(), DebugColor, 0.1f * DeltaTime);
        DrawDebugString(GetWorld(), FVector(0, 0, 120), bReleaseToShoot ? "Release to shoot" : "Hold & left click to shoot", GetOwner(), FColor::White, 0.1f * DeltaTime);
        DrawDebugString(GetWorld(), FVector(0, 0, 140), FString::Printf(TEXT("Throw Multiplier: %f"), ThrowMultiplier), GetOwner(), FColor::White, 0.1f * DeltaTime);
        DrawDebugString(GetWorld(), FVector(0, 0, 160), FString::Printf(TEXT("Range Multiplier: %f"), ThrowRange), GetOwner(), FColor::White, 0.1f * DeltaTime);
    }

    if (bIsAiming)
    {
        Ray();

        if (TrajectoryPoints.Num() > 0)
        {
            UpdateTrajectoryMaterials();
            UpdateTrajectoryMeshes(TrajectoryPoints);
        }
    }
}

<h2 style="color: gray;">//Raycast from the player to the mouse position, also calculate player and camera distance</h2>
void UPlayerThrowComponent::Ray()
{
    FVector2D MousePosition;
    APlayerController* PlayerControllerRef = UGameplayStatics::GetPlayerController(GetWorld(), 0);

    if (!PlayerControllerRef || !PlayerControllerRef->GetMousePosition(MousePosition.X, MousePosition.Y))
    {
        return;
    }

    FVector WorldLocation, WorldDirection;
    if (!UGameplayStatics::DeprojectScreenToWorld(PlayerControllerRef, MousePosition, WorldLocation, WorldDirection))
    {
        return;
    }

    APlayerCameraManager* PlayerCamera = GetWorld()->GetFirstPlayerController()->PlayerCameraManager;
    if (!PlayerCamera)
    {
        return;
    }

    FVector CameraLocation = PlayerCamera->GetCameraLocation();
    float PlayerAndCameraDistance = FVector::Distance(PlayerControllerRef->GetPawn()->GetActorLocation(), CameraLocation);

    FVector Start = WorldLocation;
    FVector End = Start + WorldDirection * (ThrowRange + PlayerAndCameraDistance);

    DrawDebugSphere(GetWorld(), GetOwner()->GetActorLocation(), ThrowRange, 8, FColor::Red, false, -1.f, 0);

    FHitResult Hit;
    TArray<AActor*> ActorsToIgnore = { GetOwner() };
    TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes = {
        UEngineTypes::ConvertToObjectType(ECC_WorldStatic),
        UEngineTypes::ConvertToObjectType(ECC_Pawn)
    };

    bool ActorHit = UKismetSystemLibrary::LineTraceSingleForObjects(GetWorld(), Start, End, ObjectTypes, false, ActorsToIgnore, EDrawDebugTrace::None, Hit, true, FLinearColor::Red, FLinearColor::Green, 0.05f);

    bRayHit = ActorHit;

    if (ActorHit && Hit.GetActor())
    {
        float ThrowHeight = FVector::Distance(PlayerControllerRef->GetPawn()->GetActorLocation(), Hit.ImpactPoint) / 2 * ThrowMultiplier;
        DrawThrowCurve(PlayerControllerRef->GetPawn()->GetActorLocation(), Hit.ImpactPoint, ThrowHeight, SmoothnessOfCurve, FColor::Green);
    }
    else 
    {
        // If the ray doesn't hit anything, draw the curve to the end of the throw range
        FVector MousePosAtEdge = Start + WorldDirection * ThrowRange;
        float ThrowHeight = FVector::Distance(PlayerControllerRef->GetPawn()->GetActorLocation(), MousePosAtEdge) / 2 * ThrowMultiplier;
		DrawThrowCurve(PlayerControllerRef->GetPawn()->GetActorLocation(), MousePosAtEdge, ThrowHeight, SmoothnessOfCurve, FColor::Red);
    }
}

<h2 style="color: gray;">//Draw the throw curve.</h2>
void UPlayerThrowComponent::DrawThrowCurve(const FVector& StartPoint, const FVector& EndPoint, float HeightOffset, int32 NumPoints, FColor Color)
{
    if (NumPoints < 2) return;

    TArray<FVector> NewTrajectoryPoints;
    NewTrajectoryPoints.Reserve(NumPoints);

    NewTrajectoryPoints.Add(StartPoint);

    float HeightOffset4 = 4.0f * HeightOffset;

    for (int32 i = 1; i < NumPoints - 1; ++i)
    {
        // Calculate t parameter between 0 and 1
        float t = static_cast<float>(i) / (NumPoints - 1);

        // Calculate the point on the line between StartPoint and EndPoint
        FVector Point = FMath::Lerp(StartPoint, EndPoint, t);

        // Calculate the parabolic height offset
        float ParabolicHeight = FMath::Square(t - 0.5f) * HeightOffset4 - HeightOffset;

        // Adjust the Z component of the point to create the curve
        Point.Z -= ParabolicHeight;

        NewTrajectoryPoints.Add(Point);
    }

    NewTrajectoryPoints.Add(EndPoint);
    TrajectoryPoints = MoveTemp(NewTrajectoryPoints);
}

<h2 style="color: gray;">//Update the trajectory materials</h2>
void UPlayerThrowComponent::UpdateTrajectoryMaterials()
{
    if(GEngine && !CanShootMaterial && !CannotShootMaterial)
	{
		GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, TEXT("Missing CanShootMaterial in the ThrowComponent"));
		return;
	}

    UMaterial* SelectedMaterial = bRayHit ? CanShootMaterial : CannotShootMaterial;

    for (UStaticMeshComponent* MeshComponent : TrajectoryMeshes)
    {
        if (MeshComponent)
        {
            MeshComponent->SetMaterial(0, SelectedMaterial);
        }
    }
}

<h2 style="color: gray;">//Update the trajectory meshes</h2>
void UPlayerThrowComponent::UpdateTrajectoryMeshes(const TArray<FVector>& Points)
{
    float SegmentSize = 1.0f / FMath::Max(1, Points.Num());

    for (int32 i = 0; i < Points.Num(); ++i)
    {

        float NormalizedIndex = (i + 1) * SegmentSize;
        float ScaleValue = 0.1f;

        if (SizeCurve)
        {
            ScaleValue = SizeCurve->GetFloatValue(NormalizedIndex);
        }

        if (i < TrajectoryMeshes.Num())
        {
            TrajectoryMeshes[i]->SetWorldLocation(Points[i]);
            TrajectoryMeshes[i]->SetWorldScale3D(FVector(ScaleValue));
            TrajectoryMeshes[i]->SetVisibility(true);
        }
        else
        {
            UStaticMeshComponent* MeshComponent = NewObject<UStaticMeshComponent>(this);
            MeshComponent->RegisterComponent();
            MeshComponent->AttachToComponent(GetOwner()->GetRootComponent(), FAttachmentTransformRules::KeepRelativeTransform);
            MeshComponent->SetStaticMesh(LineMesh);
            MeshComponent->SetWorldLocation(Points[i]);
            MeshComponent->SetWorldScale3D(FVector(ScaleValue));
            MeshComponent->SetVisibility(true);

            TrajectoryMeshes.Add(MeshComponent);
        }
    }

    for (int32 i = Points.Num(); i < TrajectoryMeshes.Num(); ++i)
    {
        TrajectoryMeshes[i]->SetVisibility(false);
    }
}

<h2 style="color: gray;">//Clear the trajectory meshes.</h2>
void UPlayerThrowComponent::ClearTrajectoryMeshes()
{
    for (UStaticMeshComponent* MeshComponent : TrajectoryMeshes)
    {
        MeshComponent->DestroyComponent();
    }
    TrajectoryMeshes.Empty();
}

<h2 style="color: gray;">//Spawn the projectile and set the trajectory points.</h2>
void UPlayerThrowComponent::SpawnAndFollowProjectile(const TArray<FVector>& _TrajectoryPoints)
{
    if (ProjectileClass == nullptr && GEngine)
    {
        GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, TEXT("Missing projectile to spawn"));
        return;
    }
    if (GetWorld())
    {
        AAProjectile* AProjectile = GetWorld()->SpawnActor<AAProjectile>(ProjectileClass, TrajectoryPoints[1], FRotator::ZeroRotator);
        AProjectile->SetTrajectoryPoints(_TrajectoryPoints);

        if (UnitToSpawn != nullptr) 
        {
            AProjectile->ToSpawnClass = UnitToSpawn;
        }
        else if(GEngine)
        {
	    GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, TEXT("Missing troop to spawn in the ThrowComponent"));
        }  
    }
}

                                </code></pre>
                              </div>
                            </div>
                            </div>
                          
                            <div class="my-line"></div>

                            <div style="display: flex; align-items: center;">
                              <img style="height: 30%; width: 30%; margin: 5%;" src="images/GP3/KeyToDoorShowcase.gif">
                              <div style="margin-left: 10px; display: flex; flex-direction: column; justify-content: center;">
                                <h2 style="color: #fabf66;">Key that opens doors -> Tldr</h2>
                                <p>A key when the player is close will start following the player and when the player gets close to the door will open the door.</p>
                              </div>
                          </div>
                            
  
                            <div class="box">
                              <h3 class="oswald-font">Key | Code</h3>
                              <h3 class="click-this">Click Here</h3>
                              <div class="hidden-text">
                                <div class="code-snippet">
                                  <pre><code id="codeBlock">
void AAKey::BeginPlay()
{
	Super::BeginPlay();

	if (DoorsInScene.Num() == 0) 
	{
		TArray<AActor*> TempActors;
		UGameplayStatics::GetAllActorsOfClass(GetWorld(), AAGate::StaticClass(), TempActors);

		for(AActor* Actor : TempActors)
		{
			AAGate* Gate = Cast<AAGate>(Actor);
			if(Gate)
			{
				DoorsInScene.Add(Gate);
			}
		}
	}

	if (DoorsInScene.Num() == 0)
		GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT("No Door Found In Scene"));
}

void AAKey::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

	switch (EState)
	{
		case KeyState::Idle:
				PickUp();
			break;

		case KeyState::FollowingPlayer:
				FollowPlayer();
			break;

		case KeyState::OpeningDoor:
				OpenDoor();
			break;
	}

	if (GEngine) 
	{
		DrawDebugSphere(GetWorld(), GetActorLocation(), DetectionRange, 20, FColor::Red, false, 0.f, 0, .5f);
		DrawDebugString(GetWorld(), GetActorLocation(), UEnum::GetValueAsString(EState), nullptr, FColor::Red, 0.1f * DeltaTime, true);
	}
}

void AAKey::PickUp()
{
	FVector PlayerLocation = GetWorld()->GetFirstPlayerController()->GetPawn()->GetActorLocation();
	FVector KeyLocation = GetActorLocation();

	float Distance = FVector::Dist(PlayerLocation, KeyLocation);

	if (Distance < DetectionRange)
	{
		EState = KeyState::FollowingPlayer;
	}
}

void AAKey::FollowPlayer()
{
	FVector KeyLocation = GetActorLocation();
	FVector PlayerLocation = GetWorld()->GetFirstPlayerController()->GetPawn()->GetActorLocation();

	MoveAndRotateTowards(KeyLocation, PlayerLocation, Speed, MinDistance);

	if (DoorsInScene.Num() > 0)
	{
		for (int i = 0; i < DoorsInScene.Num(); i++) 
		{
			FVector DoorLocation = DoorsInScene[i]->GetActorLocation();

			if (FVector::Dist(KeyLocation, DoorLocation) < DetectionRange)
			{
				DoorToOpen = DoorsInScene[i];
				EState = KeyState::OpeningDoor;
			}
		}
	}
}

void AAKey::OpenDoor()
{
	if (DoorToOpen == nullptr)
		return;

	FVector CurrentLocation = GetActorLocation();
	FVector DoorLocation = DoorToOpen->GetActorLocation();
	FVector LockLocation = DoorLocation + DoorToOpen->GetActorRightVector() * 100;
	float DeltaTime = GetWorld()->GetDeltaSeconds();

	FVector NewLocation = FMath::Lerp(CurrentLocation, LockLocation, Speed * DeltaTime);
	FVector Direction = DoorLocation - CurrentLocation;
	Direction.Normalize();

	if (!CurrentLocation.Equals(LockLocation, 10))
		SetActorLocation(NewLocation);

	SetActorRotation(Direction.Rotation());

	if (FVector::Dist(CurrentLocation, LockLocation) < 20)
	{
		DoorsInScene.Remove(DoorToOpen);
		DoorToOpen->OpenGate();
		AnimateKey();
	}
}

void AAKey::MoveAndRotateTowards(FVector CurrentLocation, FVector TargetLocation, float NewSpeed, float NewMinDistance)
{
	float DeltaTime = GetWorld()->GetDeltaSeconds();

	FVector Direction = TargetLocation - CurrentLocation;
	Direction.Normalize();

	FVector NewLocation = FMath::Lerp(CurrentLocation, TargetLocation, NewSpeed * DeltaTime);

	if (FVector::Dist(CurrentLocation, TargetLocation) > NewMinDistance)
	{
		SetActorLocation(NewLocation);
	}

	SetActorRotation(Direction.Rotation());
}
                                  </code></pre>
                                </div>
                              </div>
                              </div>

                          <div class="my-line"></div>

                        <h2 class="oswald-font"; style="text-align:center">Thank you for reading.</h2>
                    </div>  
                    
            </div>
        </div>
        <script src="script.js"></script>
        <script>
          Prism.HighlightAll();
        </script>
    </body>
</html>

</div>